% Prof. Dr. Ausberto S. Castro Vera
% UENF - CCT - LCMAT - Curso de Ci\^{e}ncia da Computa\c{c}\~{a}o
% Campos, RJ,  2022
% Disciplina: Paradigmas de Linguagens de Programa\c{c}\~{a}o
% Aluno: Ricardo Willian Pontes da Silva


\chapter{ Conceitos b\'{a}sicos da Linguagem Python}

Neste capítulo será apresentado conceitos básicos da linguagem Python, como, seus tipos primitivos de variáveis e constantes presentes na linguagem, suas estruturas, sua sintaxe e semântica e também seu o uso de pacotes disponíveis para a construção de códigos. Os livros b\'{a}sicos para o estudo da Linguagem Python s\~{a}o:\cite{Manzano2018} ,\cite{Summerfield2013}, \cite{Guttag2015}, \cite{Perkovic2016}


Considerando que a linguagem Python (\cite{Manzano2018}) \'{e} definida como sendo pseudocódigo executável pela sua semelhança com a facilidade de entendimento de algoritmos voltados para a aprendizagem. Desta forma, nos sentiremos familiarizados com a construção de seus códigos, ou então não ocorrerá grandes dificuldades de serem entendidos.
    %%%%%%%%=================================
    \section{Vari\'{a}veis e constantes}
Antes de entendermos o que se refere a parte prática da aplicação de variáveis e constantes na linguagem Python, vale ressaltar uma nota que já foi expresso anteriormente, que se trata do fato de que nesta linguagem, tudo é classificado como objeto. Desta forma, conceitos anteriormente conhecidos de linguagens anteriores não serão mais utilizados, como a direta referência de memoria ao ocorrer a criação e alocação de variáveis.\\
Com isso, é dito que a linguagem Python é dinâmicamente tipada, o que refere ao fato de não se precisar especificar o seu tipo primitivo "tamanho que ocuparia na memória".  


    %%%%%%%%=================================
    \section{Tipos de Dados B\'{a}sicos}
 De acordo com, \cite{Menezes2016}, em Python temos variáveis de tipos primitivos como \textit{int}, que alocará números inteiro entre -2.147.483.648 a 2.147.483.647, ou seja, esse tipo de variável tem como tamanho na memória 32 bits. Temos também o tipo \textit{float}, que tem como capacidade armazenar números facionários entre $1.7*10^{-8}$ a $3.4*10^{8}$. E por fim, temos também o tipo primitivo \textit{string}, que terá seu tamanho na memória variável de acordo com sua alocação. 

\subsection{Inteiro (int)}
Dizemos que um valor atribuído a uma variável é do tipo \textit{int} se e somente se, o mesmo não houver pontos flutuantes. Abaixo está sendo representado um exemplo de atribuição na linguagem Python para um melhor entendimento.

\begin{lstlisting}
	>>> #atribuicao simples em Python (int)
	>>> numero = 2
	>>> numero += 4
	O valor final da variavel 'numero' sera 6, uma vez que 
	a mesma recebeu duas atribuicoes.
\end{lstlisting} 

Assim como em outras linguagens de programação, é possível fazer mudança de tipos de um valor já existente de uma variável para outra. Por exemplo, utilizar do chamado \textit{cast} para atribuir a uma variável do tipo \textit{int}, um valor que como já visto anteriormente, não se encaixaria nesta categoria. Abaixo será apresentado exemplos de \textit{casting} na linguagem Python.
   
\begin{lstlisting}
	>>> #atribuicao com casting na linguagem Python
	>>> x = int(3) O valor de x sera 3  
	>>> y = int(3.5) O valor de y sera 3 
	>>> z = int("3") O valor de z sera 3 
\end{lstlisting} 

\subsection{Ponto flutuante (float)}
Assim como visto anteriormente, uma variável pode ser considerada do tipo \textit{float} se a mesma contiver números facionários, ou seja, contendo números de ponto flutuante. Abaixo será apresentado um pequeno trecho de código contendo um exemplo de atribuição para um melhor entendimento.

\begin{lstlisting}
	>>> #atribuicao simples em Python (float)
	>>> numero = 2.3
	>>> valor = 2.1
	>>> total = numero + valor
	O valor final da variavel 'total' sera 4.4, uma vez que 
	a mesma recebeu a atribuicao da variavel 'numero'
	que contem 2.3 e da variavel 'valor' 2.1.
\end{lstlisting} 

A linguagem Python também conta com uma funcionalidade de retorno do tipo de uma variável existente. Essa prática tende a ajudar o programador ao decorrer do código em atividades que necessitem de uma tomada de decisão por exemplo. Abaixo será apresentado um trecho de código com o objetivo de elucidar o conteúdo.

\begin{lstlisting}
	>>> #Retorno de um tipo na linguagem Python (float)
	>>> x = 2.15.
	>>> y = 3.0
	>>> z = -0.32
	
	print(type(x))
	print(type(y))
	print(type(z))
\end{lstlisting} 
   
     %%%........................
            \subsection{String}
     %%%........................
            Um string \'{e} uma sequ\^{e}ncia de caracteres considerado como um item de dado simples. Para Python, um string \'{e} um array de caracteres ou qualquer grupo de caracteres escritos entre doble aspas ou aspas simples. Por exemplo,
    \begin{lstlisting}
    >>> #usando aspas simples
    >>> pyStr1 = 'Brasil'
    >>> print (pyStr1)  Brasil
    >>> #usando aspas duplas
    >>> pyStr2 = "Oi, tudo bem?"
    >>> print (pyStr2)
    Oi, tudo bem?
    \end{lstlisting}

    \begin{itemize}
      \item \textit{Concatena\c{c}\~{a}o de strings}\\
            Strings podem ser concatenadas utilizando o operador +, e o seu comprimento pode ser calculado utilizado o operador \texttt{len(string)}
     \begin{lstlisting}
    >>> # concatenando 2 strings
    >>> pyStr = "Brasil" + " verde amarelo"
    >>> print (pyStr)
    Brasil verde amarelo
    >>> print (len(pyStr))
    20
    \end{lstlisting}

      \item \textit{Operador de indexa\c{c}\~{a}o}\\
      Qualquer caracter de um string o sequ\^{e}ncia de caracteres pode ser obtido utilizando o operador de indexa\c{c}\~{a}o []. Existem duas formas de indexar em Python, os caracteres de um string:\\
      \begin{description}
        \item[Index com inteiros positivos] indexando a partir da esquerda come\c{c}ando com 0 e  onde 0 \'{e} o index do primeiro caracter da sequ\^{e}ncia
        \item[Index com inteiros negativos] indexando a partir da direita come\c{c}ando com -1, e onde -1 \'{e} o \'{u}ltimo elemento da sequ\^{e}ncia, -2 \'{e} o pen\'{u}ltimo elemento da sequ\^{e}ncia, e assim sucessivamente.
      \end{description}

     \begin{lstlisting}
    >>> # Indexando strings
    >>> pyStr = "Programando"
    >>> print (len(pyStr))
    11
    >>> print (pyStr)
    Brasil verde amarelo
        \end{lstlisting}




      \item \textit{Operador de Fatias}\\
      O operador de acesso a itens (caracteres individuais) tamb\'{e}m pode ser utilizado como operador de fatias, para extrair uma fatia inteira (subsequ\^{e}ncia) de caracteres de um string. O operador de Fatias possui tr\^{e}s sintaxes:\\
      \texttt{seq[ inicio ]}\\
      \texttt{seq[ inicio : fim ]} \\
      \texttt{seq[ in\'{\i}cio : fim : step ]}\\
      onde \texttt{in\'{\i}cio, fim} e \texttt{step} s\~{a}o n\'{u}meros inteiros.
     \begin{lstlisting}
    >>> # Indexando strings
    >>> pyStr = "Programando Python"
    >>> print (len(pyStr))
    11
    >>> print (pyStr)
    Brasil verde amarelo
        \end{lstlisting}

    \end{itemize}

     %%%%%%%%=================================
    \section{Tipos de Dados de Cole\c{c}\~{a}o}
    %%%%%%%%=================================
Como visto antes, variáveis só poderiam alocar em seu espaço de memória um tipo primitivo apenas, porém, neste tópico será apresentado um conceito de dados de coleção onde será possível armazenar N itens dentro de uma única variável.

     %%%........................
            \subsection{Tipos Sequenciais (tuplas)}
     %%%%%%%%=================================     
     Em Python, utilizamos as chamadas Tuplas para armazenar vários itens em uma única variável. Tupla é classificado como um dos 4 tipos de dados internos usados para armazenar coleções de dados. Uma tupla é uma coleção ordenada e imutável, a sintaxe utilizada para a implementação das Tuplas são os colchetes. \\
     
     Os itens de uma tupla são classificados como, ordenados, imutáveis e permissivos a elementos duplos além de serem indexados, ou seja, cada posição é referenciada por um índice que se inicia na posição [0], [1] e etc. Abaixo veremos um exemplo da utilização das tuplas.
     \begin{lstlisting}
     	>>> # Uso de Tuplas na linguagem Python
     	>>> ExemploTupla = ("uva", "banana", "mel", 
     	"uva")
     	>>> print(ExemploTupla)
     \end{lstlisting}
 
    As tuplas também podem receber outros tipos de dados primitivos como os que já foram citados anteriormente, como, \textit{int} e \textit{float}. Também é possível saber quantos elementos estão contidos em uma Tupla. Abaixo será expresso em um trecho de código tais utilizações.
     
    \begin{lstlisting}
    	>>> # Uso de Tuplas com diversos tipos primitivos na
            #linguagem Python
    	>>> tupla1 = ("uva", "banana", "mel")
    	>>> tupla2 = (10, -2, 8, 1, 3)
    	>>> tupla3 = (True, False, False)
    	>>> tupla4 = ("Linguagem Python", 2.4, True, 40, "Oi")
    	>>> print(len(tupla4))
    	
    \end{lstlisting} 
     
     %%%........................
            \subsection{Tipos Conjunto (set)}
     %%%........................

Assim como as Tuplas, utilizamos os chamados \textit{set} para armazenar vários itens em um única variável. Porém, o grande diferencial do tipo de dados \textit{set} é por ser uma coleção não ordenada, imutável e não indexada, vale destacar também que o tipo de dados \textit{set} não aceita dados duplicados. Abaixo será ilustrado em um trecho de código a utilização básica do comando \textit{set}, sendo armazenado dados homogêneos e heterogêneos.
    
  \begin{lstlisting}
  	>>> # Uso de sets com diversos tipos primitivos na
        #linguagem Python
  	set1 = {"uva", "banana", "mel"}
  	set2 = {1, 5, 7, 9, 3}
  	set3 = {True, False, False}
  	set4 = {"Linguagem Python", 2.4, False, 40, "Ola"}
  	
  \end{lstlisting} 

Algumas particularidades do tipo de dado de coleção \textit{set} é que como já citado anteriormente, caso já criado, não é possível alterar seus dados, porém é possível criar novos itens e também excluir dados existentes. Vale a ressalva também que o \textit{set} não é referenciado por um índice, logo é possível que os itens apareçam em uma ordem diferente toda vez que utilizados. 
     %%%........................
            \subsection{Tipos Mapeamento (dicionário)}
     %%%........................
Por fim, chegamos no tipo de dado de coleção dicionário, que se caracteriza por ser uma coleção de dados ordenada, mutável e que não permite duplicatas.Assim como os demais, o dicionário é permissivo que seja alocados diferentes tipos de dados primitivos em seu corpo de código. A estrutura de um dicionário é delimitada por chaves que tendem a armazenar os dados inseridos, como mostrado no trecho abaixo.
 \begin{lstlisting}
	>>> # Uso de dicionarios com diversos tipos primitivos 
	# na linguagem Python
	dicionario = {
	"marca": "Ford",
	"eletrico": False,
	"ano": 1964,
	"cor": ["vermelho", "branco", "azul"]
	}
	
\end{lstlisting} 


    %%%%%%%%=================================
    \section{Estrutura de Controle e Fun\c{c}\~{o}es}
    %%%%%%%%=================================

     %%%........................
            \subsection{O comando IF}
     %%%........................


      %%%........................
            \subsection{La\c{c}o FOR}
     %%%........................

     %%%........................
            \subsection{La\c{c}o WHILE}
     %%%........................


    %%%%%%%%======================
    \section{M\'{o}dulos e pacotes}
    %%%%%%%%======================



       %%%........................
            \subsection{M\'{o}dulos}
     %%%........................



          %%%........................
            \subsection{Pacotes}
     %%%........................






    C\'{o}digo fonte para a linguagem Python:
    \begin{lstlisting}
    number_1 = int(input('Ingresse o primeiro numero: '))
    number_2 = int(input('Ingresse o segundo numero: '))

    # Soma
    print('{} + {} = '.format(number_1, number_2))
    print(number_1 + number_2)

    # Substra\c{c}\~{a}o
    print('{} - {} = '.format(number_1, number_2))
    print(number_1 - number_2)

    # Multiplica\c{c}\~{a}o
    print('{} * {} = '.format(number_1, number_2))
    print(number_1 * number_2)

    # Divis\~{a}o
    print('{} / {} = '.format(number_1, number_2))
    print(number_1 / number_2)
    \end{lstlisting}





